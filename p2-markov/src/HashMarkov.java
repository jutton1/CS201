import java.util.*;


public class HashMarkov implements MarkovInterface{
   protected String[] myWords;     // Training text split into array of words
   protected Random myRandom;      // Random number generator
   protected int myOrder;			// Length of WordGrams used
   protected HashMap<WordGram, List<String>> myHashMap; /* Training text split
   such that each WordGram of a certain order in myWords is mapped to a list of
   strings that may potentially follow it*/


   /**
	 * Default constructor creates order 2 model
	 */
	public HashMarkov() {
		this(2);
	}
   
    /**
	 * Initializes a model of given order and random number generator.
	 * @param order Number of words used to generate next 
	 * random word / size of WordGrams used.
	 */
	public HashMarkov(int order){
		myOrder = order;
		myRandom = new Random();
        // Or myHashMap = new HashMap<WordGram, List<String>>()?
        myHashMap = new HashMap<>();
	}

    /**
	 * Initializes training text. Should always be called prior to
	 * random text generation.
	 */
	@Override
	public void setTraining(String text){
		myWords = text.split("\\s+");
        myHashMap.clear();

        for (int i = 0; i < (myWords.length - myOrder); i++) {
            WordGram wordGram = new WordGram(myWords, i, myOrder);
            List<String> usableString = new ArrayList<String>();
            myHashMap.putIfAbsent(wordGram, usableString);
            usableString = myHashMap.get(wordGram);
            usableString.add(myWords[i + myOrder]);
            myHashMap.put(wordGram, usableString);
        }

	}

    /**
	 * Get a list of Strings containing all words that follow
	 * from wgram in the training text.
     * Implemented by using .get method on myHashMap
	 * @param wgram is a WordGram to search for in the text
	 * @return List of words following wgram in training text.
	 * May be empty.
	 */
	@Override
	public List<String> getFollows(WordGram wgram) {

        List<String> empty = new ArrayList<String>();
        if (myHashMap.containsKey(wgram)) {
            return myHashMap.get(wgram);
        }
        return empty;
    }

    /**
	 * Generates length random words based on training text.
	 * Initial words are a random WordGram taken from the training text.
	 * Subsequent words are generated by getting a random word from myHashMap.get(wordgram)
	 * WordGram, which is then shifted to include the newly generated 
	 * word at the end. Words are separated by spaces in returned string.
	 * @param length Number of words to generate
	 * @returns length randomly generated words using Markov model, 
	 * separated by spaces
	 */
	@Override
	public String getRandomText(int length){
		ArrayList<String> randomWords = new ArrayList<>(length);
		int index = myRandom.nextInt(myWords.length - myOrder + 1);
		WordGram current = new WordGram(myWords,index,myOrder);
		randomWords.add(current.toString());

		for(int k=0; k < length-myOrder; k += 1) {
			String nextWord = getNext(current);
			randomWords.add(nextWord);
			current = current.shiftAdd(nextWord);
		}
		return String.join(" ", randomWords);
	}

    private String getNext(WordGram wgram) {
		List<String> follows = getFollows(wgram);
		if (follows.size() == 0) {
			int randomIndex = myRandom.nextInt(myWords.length);
			follows.add(myWords[randomIndex]);
		}
		int randomIndex = myRandom.nextInt(follows.size());
		return follows.get(randomIndex);
	}

    @Override
    public int getOrder() {
       return myOrder;
    }

    @Override
    public void setSeed(long seed) {
       myRandom.setSeed(seed);
    }


}
